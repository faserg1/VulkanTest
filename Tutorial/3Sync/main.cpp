/* В этом уроке теперь присутствует класс Render, из которого мы будем доставать всю необходимую информацию,
 * а также класс Logger,  котором покажем, как можно в DebugReport использовать pUserData.
 * Все интересующие вас подробности смотрите здесь:
 * https://www.khronos.org/registry/vulkan/specs/1.0-wsi_extensions/pdf/vkspec.pdf
 * © Серый Волк.
*/
#include "Render.h"
#include "Logger.h"
#include "common.h"
int main()
{
	// Вкратце о том, что всё это делает:
	Render r; //объект, отвечающий за отрисовку
	Logger logger; //логгер, отвечает за вывод на экран и в файл сообщения Vulkan
	r.EnableDebug(true); //включение отладки 
	r.AddInstanceLayer("VK_LAYER_LUNARG_standard_validation"); //добавление проверочных слоёв
	r.AddDeviceLayer("VK_LAYER_LUNARG_standard_validation"); 
	r.CreateInstance(); //создание экземпляра
	logger.Init(r.GetInstance()); //инициализация (получение Vulkan функций)
	logger.AttachLogger(r.GetInstance()); //присоединение callback
	r.CreateDevice(); //создание устройства
	VkQueue queue = r.GetQueue(0); //получение очереди
	VkCommandPool pool = r.CreateCommandPool(true, false); //создание пула
	//Отлично! Теперь давайте разберёмся с синхронизацией.
	//--------------------------------------------------------------------------------------
	//Заборы (fences)
	//--------------------------------------------------------------------------------------
	/* Для начала самый простой метод синхронизации: забор. Фактически, забор самый примитивный способ
	 * ожидания выполнения команд на устройстве.
	 * У забора есть два состояния обычное и сигнальное. Подробнее о состояниях будет рассказано ниже.
	 * Создаются они таким образом:
	*/
	VkFence fence = VK_NULL_HANDLE;
	VkFenceCreateInfo fence_create_info;
	ZM(fence_create_info);
	fence_create_info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
	/* У этой структуры также есть флаги. В данный момент доступен лишь один флаг:
	 * VK_FENCE_CREATE_SIGNALED_BIT, который приведёт наш забор в сигнальное состояние. Для примера 
	 * поставим этот флаг.
	 * pNext должен быть NULL.
	*/
	fence_create_info.flags = VK_FENCE_CREATE_SIGNALED_BIT;
	vkCreateFence(r.GetDevice(), &fence_create_info, NULL, &fence);
	/* Теперь есть специальная функция, которая будет ждать все необходимые заборы.
	 * Так как наш забор уже изначально в сигнальном состоянии, эта функция нас сразу же пропустит.
	 * Первый параметр — устройство.
	 * Второй — кол-во заборов.
	 * Третий — заборы.
	 * Четвёртый — ожидать ли все заборы или только один из списка.
	 * Если забор один, значение этого параметра не имеет разницы.
	 * Пятый — время ожидания. Если значение макисмальное для uint64_t — это считается бесконечностью.
	 * Измеряется в наносекундах. Так что скорее всего тут будут достаточно большие числа для ожидания
	 * чего-то крупного. В данном случае этот параметр значения не имеет, так как наш забор уже просигнален.
	 * Если истечёт время — VK_TIMEOUT, если забор просигнален — VK_SUCCESS.
	 * Кстати, так как мы этот забор никуда не посылали, то нам должен дебаг репорт выдать об этом предупреждение.
	 * Предупреждение в консоли теперь подсвечиваются жёлтым.
	*/
	if (vkWaitForFences(r.GetDevice(), 1, &fence, false, 0) != VK_SUCCESS)
		return 1;
	/* Если вы всё ещё мне не верите, то давайте это проверим другим способом.
	 * vkGetFenceStatus получает состояние забора.
	 * Может вернуть два значения (при удаче):
	 * VK_SUCCESS, если забор просигнален
	 * VK_NOT_READY, если забор в обычном состоянии
	 * Эта функция может провалится, если у кого-то не хватает памяти, или устройство куда-то потеряется.
	*/
	if (vkGetFenceStatus(r.GetDevice(), fence) != VK_SUCCESS)
		return 23432642; //И закрываем приложение с рандомным числом.
	/* Надеюсь, теперь вы мне поверели. А теперь перезапустим забор с помощью функции vkResetFences.
	 * Эта функция также может провалится, если у кого-то не хватает памяти.
	 * Вернуть в обычное состояние можно и несколько заборов, о чём говорят нам параметры этой функции.
	 * В случае ошибки закроем приложение. 
	*/
	if (vkResetFences(r.GetDevice(), 1, &fence) != VK_SUCCESS)
		return 1;
	/* Теперь самое интересное. Помните, что нам выдал vkWaitForFences? Удачу. То есть он всё же
	 * сначала проверяет, потом "считает время", примерно как do-while.
	 * А теперь мы сделаем то же самое, только наш забор уже не будет в сигнальном состоянии.
	 * Поэтому он нам вернёт VK_TIMEOUT.
	*/
	 if (vkWaitForFences(r.GetDevice(), 1, &fence, false, 0) != VK_TIMEOUT)
		return 1;
	/* Теперь забор можно разрушить, а то в логе будет сиять красным по чёрному (ну или как вы захотели
	 * повыпендриваться с консолью/терминалом?) ошибка. Убить забор можно следующим образом:
	*/ 
	vkDestroyFence(r.GetDevice(), fence, NULL);
	//Функция значения не возвращает
	//--------------------------------------------------------------------------------------
	//Семафоры (semaphores)
	//--------------------------------------------------------------------------------------
	/* И так, если забор, это примитивный способ ожидания устройства, то семафор — простой способ синхронизации
	 * внутри устройства, т.е. даже проверить состояние на хосте уже нельзя. Но не смотря на свою примитивность, эта вещь
	 * весьма полезная. Используется для того, чтобы разные команды не мешали друг друг читать и записывать данные, а также
	 * в некоторых случаях для редких ресурсов (о них будет расказано в следующих уроках).
	 * Что делает семафор: он заставляет ждать выполнение команд в буфере, пока команды другого буфера не достигнут какой-то
	 * определённой точки. Точка определяется конвейером (pipeline) Vulkan (подробнее о конвейре будет рассказно в следующих
	 * уроках). И так, чтобы продемонстрировать его действие, создадим два простых командных буфера.
	*/ 
	VkCommandBuffer command_buffers[2];
	VkCommandBufferAllocateInfo command_buffers_info;
	ZM(command_buffers_info);
	command_buffers_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
	command_buffers_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; //первичный буфер
	command_buffers_info.commandPool = pool; //пул, с которого будем выделять буферы.
	command_buffers_info.commandBufferCount = 2; //кол-во командных буферов
	if (vkAllocateCommandBuffers(r.GetDevice(), &command_buffers_info, command_buffers) != VK_SUCCESS)
		return 2;
	//и запишем в них простые команды.
	VkCommandBufferBeginInfo begin_info;
	ZM(begin_info);
	begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
	for (uint8_t i = 0; i < 2; i++)
	{
		vkBeginCommandBuffer(command_buffers[i], &begin_info);
		VkViewport viewport;
		viewport.x = 0;
		viewport.y = 0;
		viewport.width = 1024;
		viewport.height = 768;
		viewport.minDepth = 0;
		viewport.maxDepth = 1;
		vkCmdSetViewport(command_buffers[i], 0, 1, &viewport);
		vkEndCommandBuffer(command_buffers[i]);
	}
	/* Теперь нужно создать один семафор. Как ни странно, но даже если тут и есть подобие флагов... то даже они зарезервированы
	 * для будущего испольования и сейчас их просто нет!
	*/
	VkSemaphore semaphore = VK_NULL_HANDLE;
	VkSemaphoreCreateInfo semaphore_info;
	ZM(semaphore_info);
	semaphore_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
	vkCreateSemaphore(r.GetDevice(), &semaphore_info, NULL, &semaphore);
	/* А теперь нужно сделать так, чтобы первый сначала выполнились команды из первого буфера, затем из второго.
	 * Для этого надо правильно заполнить структуры (!) VkSubmitInfo. В одной мы будем сигнализировать наш семафор,
	 * в другой будем ждать его. Для начала простенько заполним общие данные.
	*/
	VkSubmitInfo submit_info[2];
	for (uint8_t i = 0; i < 2; i++)
	{
		ZM(submit_info[i]);
		submit_info[i].sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
		submit_info[i].commandBufferCount = 1; //кол-во буферов, которые мы хотим отправить
		submit_info[i].pCommandBuffers = &command_buffers[i]; //буферы
	}
	/* Для начала настроем первый submit на сигнализирование.Здесь всё относительно просто.
	*/
	submit_info[0].signalSemaphoreCount = 1; //кол-во семафоров, которые надо просигнались
	submit_info[0].pSignalSemaphores = &semaphore ; //сами семафоры
	/* Теперь настроем второй submit на ожидание. 
	*/
	submit_info[1].waitSemaphoreCount = 1; //кол-во семафоров, которые надо ждать
	submit_info[1].pWaitSemaphores = &semaphore; //сами семафоры
	/* А теперь вкусненькое. Дальше нужно указать маску ожидания для каждого из семафоров.
	 * Маска настраивается с помощью VkPipelineStageFlags флагов. Так как мы хотим подождать выполнение всех команд,
	 * поэтому поставим VK_PIPELINE_STAGE_ALL_COMMANDS_BIT.
	*/
	VkPipelineStageFlags semaphore_wait_masks[1] = {VK_PIPELINE_STAGE_ALL_COMMANDS_BIT};
	submit_info[1].pWaitDstStageMask = semaphore_wait_masks;
	/*Можно также подождать и завершения лишь одной части конвейера, указав для этого специальный флаг. Но об этом
	 * в следующих уроках.
	 * 
	 * Посылаем наши буферы в очередь.
	*/
	vkQueueSubmit(queue, 2, submit_info, VK_NULL_HANDLE);
	/* Теперь эти команды выполнятся по очереди. Хотите пруф? А не будет вам. Потом сами проверите. Пока что просто поверьте
	 * мне наслово.
	 * 
	 * Теперь можно уничтожить семафор. Но всё равно помните, что для начала, нужно подождать завершения
	 * всех командных буферов, которые используют этот семафор. Я снова воспользуюсь простой функцией
	 * ожидания заверешения команд во всей очереди. Удобная вещь, когда хочешь полностью закночить с чем-то работу.
	*/
	vkQueueWaitIdle(queue);
	/*Начиная с версии 1.0.8 (и пока не выйдет фикс) это каманда генерирует ошибку в слое DS,
	 * хотя семафоры мы использовали нормально. Это баг в слое, так что ждём исправлений.
	 * Вот пруф:
	 * https://github.com/KhronosGroup/Vulkan-LoaderAndValidationLayers/issues/100
	*/
	vkDestroySemaphore(r.GetDevice(), semaphore, NULL);
	//--------------------------------------------------------------------------------------
	//События (events)
	//--------------------------------------------------------------------------------------
	/* У событий особая роль: они могут быть сигнализированы как в устройстве, так и на хосте, и проверены
	 * как внутри утройства с помощью команды, так и с помощью функции на хосте. Но с некоторой оговоркой.
	 * Ждать хост устройство может спокойно, а вот ждать видеокарту хосту не стоит. Он, конечно, может проверить состояние
	 * события с помощью vkGetEventStatus(device, event), но проверяет он не определённый статус конвейера, а есть ли сигнал вообще.
	 * Да, события также настраиваются на позицию конвейера, как и семафоры, но события, так или иначе, более гибкие.
	*/ 
	//Создадим события
	VkEvent events[2];
	//pNext и флаги зарезервированы для будущего использвания. Сейчас всё по нулям.
	VkEventCreateInfo event_create_info;
	ZM(event_create_info);
	event_create_info.sType = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
	for (uint8_t i = 0; i < 2; i++)
	{
		events[i] = VK_NULL_HANDLE;
		//проверять на ошибки в данном случае не будем. мне лень.
		vkCreateEvent(r.GetDevice(), &event_create_info, NULL, &events[i]); 
	}
	/* И так, про функцию. Возвращает при удаче два значения
	 * VK_EVENT_RESET — если событие не просигналено
	 * VK_EVENT_SET — если наборот — просигналено.
	 * Можем даже сейчас проверить:
	*/
	if (vkGetEventStatus(r.GetDevice(), events[0]) != VK_EVENT_RESET) 
		return 1;
	/* Теперь попробуем подождать событие внутри устройства.
	 * Для начала в submit info уберём информацию о семафорах. Для этого просто скажем, что их кол-во равняется 0.
	 * После этого маски и хэндлы будут игнорироваться.
	*/ 
	submit_info[0].signalSemaphoreCount = 0;
	submit_info[1].waitSemaphoreCount = 0;
	vkBeginCommandBuffer(command_buffers[0], &begin_info);
	/* Посмотрим на команду ожидания событий:
	*/ 
	vkCmdWaitEvents(command_buffers[0], //указываем буфер, которому нужно ждать.
		1, //указываем кол-во событий
		&events[0], //сами события
		/* Указываем, что мы ждём. В данном случае, мы ждё хост.
		 * Также, можно настроить на ожидание другого буфера, но для этого нужно указать флаги позиции конвейера, при котором
		 * этот буфер сигналит события.
		 * Как бы то ни было, слой DrawState будет ругаться на этот параметр. Потому что это баг. Причём, в версии 1.0.5
		 * выдавал один текст, теперь выдаётся другой. Хотя вроде бы мы всё использовали правильно. Вроде бы эту фишку пофиксили,
		 * поэтому ждём 1.0.9.
		*/ 
		VK_PIPELINE_STAGE_HOST_BIT,
		/* Позиции конвейера, которые ждут просигналеных событий. В данном случае, мы указываем самое начало.
		 * То есть, буфер не начнёт выполняться, пока мы не подадим сигнал.
		*/ 
		VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
		//Далее идут барьеры, о которых мы поговорим позже
		0, NULL, //кол-во и барьеры памяти
		0, NULL, //кол-во и барьеры буферов
		0, NULL //кол-во и барьеры изображений
		);
	vkEndCommandBuffer(command_buffers[0]);
	//Теперь отсылаем буфер.
	vkQueueSubmit(queue, 1, &submit_info[0], VK_NULL_HANDLE);
	//Всё, наше устройство ждёт момента, когда мы просигналим ей. Для подачи сигнала нужно использовать следующую функцию:
	if (vkSetEvent(r.GetDevice(), events[0]) != VK_SUCCESS)
		return 1;
	/* Здесь всё просто. Первым параметром устройство, вторым — хэндл события.
	 * Теперь нужно подождать, пока всё выполниться.
	*/ 
	vkQueueWaitIdle(queue);
	//Также можно вернуть события в обычное состояние.
	vkResetEvent(r.GetDevice(), events[0]);
	/* Также, есть следующие команды:
	 * vkCmdSetEvent(buffer, event, stage)
	 * Которое переведёт событие в просигналеное состояние, когда конвейер достигнет позиции stage.
	 * И наоборот, вернёт событие в обычное состояние следующая команда:
	 * vkCmdResetEvent(buffer, event, stage), которая также работает при достижении определённой позиции конвейера.
	 * Уничтожим события.
	*/
	for (uint8_t i = 0; i < 2; i++)
	{
		vkDestroyEvent(r.GetDevice(), events[i], NULL);
	}
	//--------------------------------------------------------------------------------------
	//Барьеры
	//--------------------------------------------------------------------------------------
	/* Барьеры фактически позволяют защитить какие-либо участки кода от несвоевременного чтения, выполнения и записи.
	 * И барьеры бывают 4 видов:
	 * Барьер конвейера.
	 * Барьер памяти
	 * Барьер буферов
	 * Барьер изображений
	 * Первый может содержать в себе три остальных. Также и другие примитивы синхронизации могут использовать три последних
	 * барьера.
	*/
	
	//--------------------------------------------------------------------------------------
	r.DestroyCommandPool(pool);
	r.DestroyDevice();
	logger.DetachLogger(r.GetInstance());
	r.DestroyInstance();
	return 0;
}